# 📌 <b>Prop Types</b>

#### 컴포넌트들이 매우 많은 props를 지닐 때, prop에 잘못된 값을 보내는 실수를 할 수 있다.

<br>

#### ex) 버튼의 이름을 나타내는 text prop에 string type을 보내는 대신에 number를 넘겨주고, 버튼 이름의 크기를 설정하는 fontSize prop에 number type을 보내는 대신에 text와 같은 string을 넘겨줄 수도 있다.

<br>

#### 위와 같은 경우 규칙에 어긋나게 코드를 작성하지는 않았으므로 에러가 발생하지는 않는다.

#### but, 우리가 직접 만든 컴포넌트 방식 내에서는 에러와도 같다.

#### 이럴 때, React에서 우리가 실수를 했다고 알려주면 좋을 것이지만 아직 React는 우리가 어떤 prop에 어떤 것을 받고 싶어하는지에 대해 모른다.

#### (우리는 text prop에 string 값이 들어가기를 원하고, fontSize prop에 number가 들어가기를 원한다.)

<br>

### 위과 같은 문제를 해결하기 위해 React team으로부터 만들어진 **PropTypes**라는 이름의 한 패키지가 존재한다.

### **PropTypes**는 어떤 type의 prop을 받고 있는지를 체크해준다.

#### 아래와 같이 script tag에 주소를 작성하면 사용할 수 있다.

<br>

```jsx
// 이전의 react 가져오는 주소 production.min --> development 로 수정
<script src="https://unpkg.com/react@17.0.2/umd/react.development.js"></script>
<script src="https://unpkg.com/prop-types@15.7.2/prop-types.js"></script>
```

#### 현재 console 창에 PropTypes 라고 작성해 보면 PropTypes 객체에 접근할 수 있는 것을 볼 수 있다.

#### 이제 React JS에게 우리가 생성한 props의 type이 무엇인지를 알려 줄 것이다. 다음과 같이 코드를 작성한다.

```jsx
// 이전 시간의 MemorizedBtn에 이어서 사용
const MemorizedBtn = React.memo(Btn);
MemorizedBtn.propTypes = {
  // 컴포넌트명. propTypes
  text: PropTypes.string, // type을 객체 형태로 명시
  fontSize: PropTypes.number,
};
```

#### MemorizedBtn 컴포넌트의 인자로 들어가는 props의 값의 자료형을 설정하였다.

#### 객체 형태로 type을 명시하였는데, text prop에는 string type을, fontSize prop에는 number type이 들어가도록 명시하였다.

<br>

#### 다음과 같이 App 컴포넌트의 자식 컴포넌트로 들어가는 Btn 컴포넌트에 props를 부여해 보자.

<br>

```jsx
function App() {
  .....
  return (
    <div>
      <MemorizedBtn text={value} onClick={changeValue} fontSize={18} />
      <MemorizedBtn text={14} fontSize={"Continue"} />
      // Warning: Failed prop type: Invalid prop `text` of type `number` supplied to `Btn`, expected `string`.
      // Warning: Failed prop type: Invalid prop `fontSize` of type `string` supplied to `Btn`, expected `number`.
    </div>
  );
}
```

#### 2번째의 MemorizedBtn의 경우, string type prop인 text에 number인 14를 적었고, number type prop인 fontSize에 string인 'Continue'를 적었다.

#### type을 우리가 정한 규칙에 따라 적지 않았으므로 console 창에서 경고문을 볼 수 있다.

<br>

#### 2번째 MemorizedBtn을 text에 "Continue"를 적고, fontSize에 14를 적는 식으로 type을 반대로 적어주면 경고 문구 없이 정상적으로 작동하게 된다.

<br>

```jsx
function App() {
  .....
  return (
    <div>
      <MemorizedBtn text={value} onClick={changeValue} fontSize={18} />
      <MemorizedBtn text={"Continue"}  fontSize={14} />
    </div>
  );
}
```

<br>

#### string과 number 이외에도 array, bool, func, number, object, string, symbol, node, element, oneOf(oneOf의 경우 type으로 정하는 것이 아닌 특정 값 중 하나여야 한다.) 등 여러가지의 자료형을 지정할 수 있다.

<br>

### isRequired

#### 특정 props를 꼭 가지고 render가 되어야 할 때 사용한다.

#### ex)

<br>

```jsx
MemorizedBtn.propTypes = {
  text: PropTypes.string,
  fontSize: PropTypes.number.isRequired, // 주목
};
.....
  return (
    <div>
      <MemorizedBtn text={value} onClick={changeValue} fontSize={18} />
      <MemorizedBtn text={"Continue"} />     // 주목!
      // Warning: Failed prop type: The prop `fontSize` is marked as required in `Btn`, but its value is `undefined`.
    </div>
  );
}
```

#### 위의 경우 fontSize가 필수 prop이 된다.

#### 두번째 MemorizedBtn에서 필수 prop인 fontSize를 작성하지 않았다. 결과로 console 창에 fontSize의 value가 undefined라는 오류가 뜨는 것을 볼 수 있다.

<br>

### default값 설정하기

#### 다음과 같이 default값을 설정해 줄 수도 있다. (JS 문법에 존재하는 것이다.) 정의되지 않은 변수에 대한 기본값을 주는 것이다.

<br>

```jsx
function Btn({ text, onClick, fontSize = 16 }) {     // fontSize 주목!
  console.log(text, "was rendered");
  return (
  .....
```

#### 이렇게 하면 컴포넌트에 우리가 fontSize를 작성하여 넘겨주지 않을 경우 기본값으로 16이 설정되는 것을 볼 수 있다. (but default값을 설정하여도 해당 prop이 isRequired 설정되어 있고 prop에 대한 값을 넘겨주지 않은 경우 경고 문구가 뜬다.)
