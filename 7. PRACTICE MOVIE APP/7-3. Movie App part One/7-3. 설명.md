# 📌 영화 앱 만들기 시작!

### ✔️ 영화를 보여주고, 그 영화들에 대한 정보도 좀 보여주고, 거기에 링크까지 넣어 그 영화에 대해 더 많은 것을 찾아볼 수 있도록 앱에서 다른 곳으로 연결을 시켜주는 기능을 넣은 영화 앱을 제작해 볼 것이다.

<br>

#### 우리는 지금까지 하나의 상호작용이 있는 스크린을 만들어 왔다.

#### 하지만 다른 페이지로 전환하는 것을 지금부터 해 볼 것이다.

<br><br>

### **1️⃣ 가장 먼저, 영화들을 화면에 모두 보여주기 위한 API가 필요하다.**

<br>

#### 많은 영화 정보들을 받을 수 있는 **API**를 통하여 영화를 가져올 것이다.

#### 주소창에 https://yts.mx/api/v2/list_movies.json?minimum_rating=8.5&sort_by=year 라고 입력하면 json 형식의 많은 영화 데이터들을 볼 수 있다.

#### 주소에 **minimum_rating을 8.5**라고 입력하였는데, 이는 별점이 8.5점 이상인 영화들만 추출해내기 위해 작성한 것이다.

#### 또한 **sort_by=year**라고도 입력하였는데, 이는 최신 영화순으로 데이터를 보여준다.

<br><br>

### **2️⃣ 이전 시간에 했던 것과 같이 API를 모두 받아오기 전까지는 화면에 로딩 중을 보여주고, 로딩이 끝났을 때 영화들을 보여주어야 한다.**

<br>

#### **2-1.**

#### 우선 loading state를 만들어 초깃값을 true로 설정하고 (처음에는 무조건 API를 받아오는 중이므로) loading이 true일 때 화면에 Loading을 보여주고, false일 때 일단은 아무것도 보여주지 않는 코드를 작성하였다.

#### (null 자리에 나중에 영화들를 보여주는 코드가 들어갈 것이다.)

<br>

```jsx
import { useState } from "react";

function App() {
  const [loading, setLoading] = useState(true);
  return <div>{loading ? <h1>Loading...</h1> : null}</div>;
}

export default App;
```

<br>

#### **2-2.**

#### movie API는 처음 딱 한번만 받아오면 되므로 useEffect를 이용하여 API를 받아오는 코드는 한번만 실행되도록 한다.

<br>

```jsx
import { useState, useEffect } from "react";

function App() {
  const [loading, setLoading] = useState(true);
  useEffect(() => {
    // 주목!
    fetch(
      "https://yts.mx/api/v2/list_movies.json?minimum_rating=8.5&sort_by=year"
    )
      .then((response) => response.json())
      .then((json) => console.log(json));
  }, []);
  return <div>{loading ? <h1>Loading...</h1> : null}</div>;
}

export default App;
```

#### 첫번째 .then에 들어가는 함수의 인자(response)에 우리가 위 주소에 요청을 보내 받은 정보가 들어가는데 response는 HTTP 응답 전체를 나타내는 객체이다. 따라서 JSON 본문 컨텐츠만을 추출하기 위해 json 메서드를 호출하였다.

<br>

#### 두번째 .then에 들어가는 함수의 인자(json)에 아까 추출해낸 json 파일이 들어가는데, 우리는 이를 console창에서 확인해본 결과 객체를 하나 받는데, data에 속해 있는 movies 배열에 많은 영화 정보 객체들이 담겨 있는 것을 볼 수 있다.

<br>

#### 이제 받아온 movie data를 movies state를 새로 만들어 그곳에 할당해준다.

<br>

```jsx
.....
function App() {
  .....
  const [movies, setMoives] = useState([]);     // 주목!
  useEffect(() => {
    fetch(
      "https://yts.mx/api/v2/list_movies.json?minimum_rating=8.5&sort_by=year"
    )
      .then((response) => response.json())
      .then((json) => setMoives(json.data.movies));     // 주목!
  }, []);
  .....
```

<br>

#### **2-3.**

#### 이제 loading을 끝냈으므로 setLoading 함수의 인자로 false를 전달해 주어야 한다.

<br>

```jsx
unction App() {
  .....
      .then((json) => {
        setMoives(json.data.movies);
        setLoading(false);     // 주목!
  .....
```

<br>

#### 사실 요즘 보편적으로 사용하는 것은 then이 아닌 async-await이다.

<br>

#### ↪️ **async-await를 이용하여 코드 다시 작성해보기**

<br>

```jsx
function App() {
  .....
  const getMovies = async () => {
    const response = await fetch(
      `https://yts.mx/api/v2/list_movies.json?minimum_rating=8.5&sort_by=year`
    );
    const json = await reponse.json();
    setMoives(json.data.movies);
    setLoading(false);
  };
  useEffect(() => {
    getMovies();
  }, []);
  .....
```

<br>

#### 좀 더 간단하게 적고 싶으면 다음과 같이 await을 한번에 2번 적용하여 response 변수를 따로 만들지 않는 형식으로 적을수도 있다.

<br>

```jsx
function App() {
  .....
  const getMovies = async () => {
    const json = await (
      await fetch(
        `https://yts.mx/api/v2/list_movies.json?minimum_rating=8.5&sort_by=year`
      )
    ).json();
    setMoives(json.data.movies);
    setLoading(false);
  };
 .....
```

<br>

#### 다음과 같이 console.log 해서 console창에서 결과를 살펴보자.

<br>

```jsx
function App() {
  .....
  useEffect(() => {
    getMovies();
  }, []);
  console.log(movies);
  .....
```

#### 처음에 뜨는 빈 배열([])은 Loading일 때의 상태이다. (처음 렌더링될 때 상태)

#### 두 번째에 뜨는 movie 정보들이 채워진 배열은 setMovies(json.data.movies)로 movie state가 변경되었기 때문에 나타난다.

#### 세 번째에도 똑같은 배열이 뜨는데, 이는 setMovies(json.data.movies) 다음에 실행된 setLoading(false)로 인해 loading state가 변경되어 컴포넌트가 재렌더링 되었기 때문이다.

<br><br>

### **3️⃣ map 메서드를 사용하여 movies에 들어 있는 정보를 화면에 보여준다.**
